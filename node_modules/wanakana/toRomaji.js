'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _constants = require('./constants');

var _getChunkSize = require('./utils/getChunkSize');

var _getChunkSize2 = _interopRequireDefault(_getChunkSize);

var _getChunk = require('./utils/getChunk');

var _getChunk2 = _interopRequireDefault(_getChunk);

var _katakanaToHiragana = require('./utils/katakanaToHiragana');

var _katakanaToHiragana2 = _interopRequireDefault(_katakanaToHiragana);

var _isKatakana = require('./isKatakana');

var _isKatakana2 = _interopRequireDefault(_isKatakana);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert kana to romaji
 * @param  {String} kana text input
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toRomaji('ひらがな　カタカナ')
 * // => 'hiragana katakana'
 * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })
 * // => 'hiragana KATAKANA'
 */
function toRomaji() {
  var kana = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var config = Object.assign({}, _constants.DEFAULT_OPTIONS, options);
  var len = kana.length;
  // Final output array
  var roma = [];
  // Position in the string that is being evaluated
  var cursor = 0;
  var maxChunk = 2;
  var chunkSize = 2;
  var chunk = '';
  var romaChar = '';
  var nextCharIsDoubleConsonant = void 0;

  while (cursor < len) {
    chunkSize = (0, _getChunkSize2.default)(maxChunk, len - cursor);
    var convertThisChunkToUppercase = false;
    while (chunkSize > 0) {
      chunk = (0, _getChunk2.default)(kana, cursor, cursor + chunkSize);
      if ((0, _isKatakana2.default)(chunk)) {
        convertThisChunkToUppercase = config.upcaseKatakana;
        chunk = (0, _katakanaToHiragana2.default)(chunk);
      }
      // special case for small tsus
      if (chunk.charAt(0) === 'っ' && chunkSize === 1 && cursor < len - 1) {
        nextCharIsDoubleConsonant = true;
        romaChar = '';
        break;
      }

      romaChar = _constants.TO_ROMAJI[chunk];

      if (romaChar != null && nextCharIsDoubleConsonant) {
        romaChar = romaChar.charAt(0).concat(romaChar);
        nextCharIsDoubleConsonant = false;
      }
      // console.log(`${cursor}x${chunkSize}:${chunk} => ${romaChar}`);
      if (romaChar != null) {
        break;
      }
      chunkSize -= 1;
    }
    if (romaChar == null) {
      // Passthrough undefined values
      romaChar = chunk;
    }

    if (convertThisChunkToUppercase) {
      romaChar = romaChar.toUpperCase();
    }
    roma.push(romaChar);
    cursor += chunkSize || 1;
  }
  return roma.join('');
}

exports.default = toRomaji;